After this task is complete, convert your physical schema into an equivalent schema for SQLite. Record and report all the difficulties that you encountered during this process. Are there any constraints that you were not able to enforce in SQLite? 1. Domain and enumIn our implementation of the CEA in PostgreSQL, we found that many attributes shared the same constraints – the attributes associated with ranking were all integers between 1 and 5 – so we found it useful to use domain to avoid repeating declaring one constraint as well as to keep the definition of the constraint in one convenient place. We also found enum a handy tool for keeping values consistent in the attribute that indicated the time of day of a course edition.However, in SQLite, both of these functions were traded for less intuitive ones: the domain was scrapped and we repeated the constraint for every attribute that was a ranking; the enum was also removed to make way for a direct CHECK constraint on the course edition time of day.2. Date typePostgreSQL has many available functions for date value processing. Rather than separately storing the year and month when a student began his study at the university, we used a single date type attribute, which does prompt some extra data (since date is required to complete a date value), but is more efficient than two different string or int values not only for data storage but for facile manipulation in constraint definitions.On the other hand, SQLite doesn’t have a built-in date type, so we had to use a text type to collect date values. In this case, constraints needed to be defined to make sure the month was valid (ie. Between 1 and 12) and the date was valid (between 1 and 30 for certain months, 1 and 31 for some, and 1 and 28 for February). This made SQLite the less efficient and less desirable option.3.	